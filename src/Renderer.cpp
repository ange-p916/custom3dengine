// Renderer.cpp
// Implementation of the Renderer class.
// Initializes OpenGL state, manages shaders and vertex buffers,
// and draws objects using Model, View, and Projection (MVP) matrices.

#include "MyFirstEngine/Renderer.h" // Path to Renderer.h, assuming it's in include/MyFirstEngine/
#include "glad/glad.h"              // For OpenGL functions
#include <iostream>                 // For std::cerr (error output)

// Constructor: Initializes member variables
Renderer::Renderer() : VAO(0), VBO(0), shaderProgram(nullptr) {
    // VAO, VBO are initialized to 0, indicating they are not yet generated by OpenGL.
    // shaderProgram is initialized to nullptr, indicating no shader is loaded yet.
}

// Destructor: Cleans up OpenGL resources
Renderer::~Renderer() {
    // Delete the shader program if it was allocated
    if (shaderProgram) {
        delete shaderProgram;
        shaderProgram = nullptr; // Set to nullptr to avoid dangling pointer issues
    }
    // Delete the Vertex Buffer Object if it was generated
    if (VBO != 0) {
        glDeleteBuffers(1, &VBO);
        VBO = 0; // Reset ID
    }
    // Delete the Vertex Array Object if it was generated
    if (VAO != 0) {
        glDeleteVertexArrays(1, &VAO);
        VAO = 0; // Reset ID
    }
}

// Initializes the renderer
bool Renderer::init() {
    // --- 1. Load and Compile Shaders ---
    // The shader paths are relative to the executable's working directory.
    // CMakeLists.txt should copy "assets/shaders/triangle.vert" and "assets/shaders/triangle.frag"
    // to a "shaders/" subdirectory in the build output folder.
    // Ensure these shader files are the updated versions that use MVP matrices.
    shaderProgram = new Shader("shaders/triangle.vert", "shaders/triangle.frag");

    // Check if the shader program was created and linked successfully
    if (!shaderProgram || shaderProgram->ID == 0) {
        std::cerr << "ERROR::RENDERER::INIT: Failed to create or link shader program." << std::endl;
        if (shaderProgram) { // Clean up if allocated but failed
            delete shaderProgram;
            shaderProgram = nullptr;
        }
        return false; // Initialization failed
    }

    // --- 2. Set up Vertex Data, Buffers, and Attributes ---
    glGenVertexArrays(1, &VAO); // Generate a Vertex Array Object
    glGenBuffers(1, &VBO);      // Generate a Vertex Buffer Object

    glBindVertexArray(VAO); // Bind the VAO so subsequent VBO and attribute configurations are stored in it

    glBindBuffer(GL_ARRAY_BUFFER, VBO); // Bind the VBO to the GL_ARRAY_BUFFER target
    // Copy the vertex data (defined in Renderer.h's 'vertices' array) into the VBO's memory
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    // Configure vertex attributes:
    // Stride: 6 * sizeof(float) because each vertex has 3 position floats + 3 color floats.

    // Position attribute (corresponds to 'layout (location = 0)' in the vertex shader)
    // Index: 0
    // Size: 3 components (x, y, z)
    // Type: GL_FLOAT
    // Normalized: GL_FALSE
    // Stride: total size of one vertex's data in bytes
    // Pointer: offset of the position data from the start of the vertex data (0 for the first attribute)
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0); // Enable this vertex attribute

    // Color attribute (corresponds to 'layout (location = 1)' in the vertex shader)
    // Index: 1
    // Size: 3 components (r, g, b)
    // Type: GL_FLOAT
    // Normalized: GL_FALSE
    // Stride: total size of one vertex's data in bytes
    // Pointer: offset of the color data from the start of the vertex data (after 3 position floats)
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1); // Enable this vertex attribute

    // Unbind VBO (the VAO "remembers" this VBO and its attribute configuration)
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    // Unbind VAO (to prevent accidental modification)
    glBindVertexArray(0);

    // --- 3. Enable Depth Testing ---
    // This ensures that objects closer to the camera correctly occlude objects farther away.
    glEnable(GL_DEPTH_TEST);
    // glDepthFunc(GL_LESS); // Optional: specify the depth comparison function (GL_LESS is default)

    return true; // Initialization successful
}

// Draws the scene using the provided Model, View, and Projection matrices
void Renderer::draw(const Mat4& model, const Mat4& view, const Mat4& projection) {
    // --- 1. Clear Buffers ---
    // Set the clear color (background color)
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f); // Dark grey
    // Clear the color buffer and the depth buffer from the previous frame
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // --- 2. Prepare for Drawing ---
    // Check if the shader program is valid
    if (shaderProgram && shaderProgram->ID != 0) {
        shaderProgram->use(); // Activate the shader program

        // --- 3. Set Uniforms ---
        // Send the MVP matrices to the shader program.
        // The Shader class's setMat4 method takes a const float* to the matrix elements.
        // The uniform names ("model", "view", "projection") must match those in the vertex shader.
        shaderProgram->setMat4("model", model.getElementsPtr());
        shaderProgram->setMat4("view", view.getElementsPtr());
        shaderProgram->setMat4("projection", projection.getElementsPtr());

        // --- 4. Draw the Object ---
        glBindVertexArray(VAO); // Bind the VAO that contains our triangle's vertex data and attributes
        // Draw the triangle:
        // Mode: GL_TRIANGLES
        // Starting index: 0
        // Number of vertices: 3
        glDrawArrays(GL_TRIANGLES, 0, 3);

        glBindVertexArray(0); // Unbind the VAO after drawing
    } else {
        std::cerr << "ERROR::RENDERER::DRAW: Called with invalid or uninitialized shader program." << std::endl;
    }
}
